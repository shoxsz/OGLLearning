#ifndef _WIDGET_
#define _WIDGET_

#include "definitions.hpp"
#include "drawer.hpp"
#include "utils/point.hpp"
#include "utils/size.hpp"
#include "utils/rect.hpp"
#include "utils/matrix.hpp"
#include "events.hpp"

#include <map>
#include <list>
#include <string>
#include <functional>
#include <memory>
#include <vector>

/*
	An widget is a generic 2D UI element that have a rectangular shape and interacts with the mouse and keyboard,
	it can be:
		pressed, dragged, scrolled and written.
	This class provides a functional and simple widget.
	Each widget have a child list that it will use to propagate events.
	Events propagation:
		Mouse button down:
			A widget first repass this event to its childs and return when a child has caught
			the event, if no child has caught the event then the widget will process it:
				A virtual method that can be overriden by a child class will be called to process the
				event, if it returns true the widget has caught the event and so it will mark itself
				as the mouse focus within its Box and pressed, finally it will call the user defined
				callback to inform about the event.
		Mouse button up:
			A widget first repass this event to its childs and return when a child has caught
			the event, if no child has caught the event then the widget will process it:
				A virtual method that can be overriden by a child class will be called to process the
				event, if it returns true the widget has caught the event and so it will unmark itself
				as the mouse focus and unpressed, finally it will call the user defined callback to inform
				about the event.
		Mouse move:
			A widget first repass this event to its childs and return when a child has caught
			the event, if no child has caught the event then the widget will process it:
				A virtual method that can be overriden by a child class will be called to process the
				event, if it returns true the widget has caught the event and so it will mark itself
				as the mouse focus within its Box and will be marked as covered, finally it will call 
				the user defined callback to inform about the event.
		Mouse scroll:
			A widget first repass this event to its childs and return when a child has caught
			the event, if no child has caught the event then the widget will process it:
				A virtual method that can be overriden by a child class will be called to process the
				event, if it returns true the widget has caught the event and so it will call the user
				defined callback to inform about the event.
		Drag events:
			This are secondary events[0] that are generated when the widget are marked as draggable and has
			received some mouse event. This event is only processed by a widget if the widget is marked 
			as the mouse focus in its Box and is marked as draggable.
			Drag start:
				The widget will call a virtual method that can be inherited by a child class to process the
				event, if it returns true the widget has caught the event and so it will mark itself as dragged
				and then call the user callback to inform about the event.
			Drag:
				If a widget is being dragged it will call a virtual method that can be inherited by a child class to 
				process the event, if it returns true the widget has caught the event and so it will call the user
				callback to inform about the event.
			Drag end:
				If a widget is being dragged it will call a virtual method that can be inherited by a child class to
				process the event, if it returns true the widget has caught the event and so it will unmark itself as
				dragged and will call a user defined callback to inform about the event.
			Keyboard events: key down/up & text input
				This events have no propagation, they will just be repassed to child classes to process it and call
				user defined callbacks.
	Drawning:
		Each widget first draw itself and then call the childs draw methods, the widget uses a Drawer that is responsible
		for the drawning.

	[0] Secondary events are generated by a combination of primary events[1] or generated by a widget in response to some
	primary event.
	[1] Primary events are generated by the end user by any device such as keyboard, mouse, joystick, touch screen, etc.
*/

class Widget{
public:
	/*events callbacks*/

	typedef std::function<void(Widget&, const MouseButtonEvent& button)> OnMouseButtonDown;
	typedef std::function<void(Widget&, const MouseButtonEvent& button)> OnMouseButtonUp;
	typedef std::function<void(Widget&, const MouseMoveEvent& move)> OnMouseMove;
	typedef std::function<void(Widget&, const MouseScrollEvent& scroll)> OnMouseScroll;
	typedef std::function<void(Widget&, const MouseMoveEvent& drag)> OnStartDrag;
	typedef std::function<void(Widget&, const MouseMoveEvent& drag)> OnDrag;
	typedef std::function<void(Widget&, const MouseMoveEvent& drag)> OnEndDrag;
	typedef std::function<void(Widget&, const KeyboardEvent& keyboard)> OnKeyDown;
	typedef std::function<void(Widget&, const KeyboardEvent& keyboard)> OnKeyUp;
	typedef std::function<void(Widget&, const TextInputEvent& input)> OnTextInput;

	Widget();
	virtual ~Widget();

	void setBox(Box* box){ this->box = box; }
	Box* getBox(){ return box; }

	void draw();

	void setPosition(const Point& position) { this->position = position; }
	Point& getPosition() { return position; }
	const Point& getPosition()const { return position; }

	void setSize(const Size& size){ this->size = size; }
	Size& getSisze(){ return size; }
	const Size& getSize()const{ return size; }

	Rect getRect()const{return Rect(position, size);}

	void setZOrder(int zOrder) {
		this->zOrder = zOrder;
		if (parent)
			parent->swapZOrder(this, zOrder);
	}

	unsigned int getZOrder()const { return zOrder; }

	void setDrawer(DrawerPtr drawer){ this->drawer = drawer; }
	DrawerPtr getDrawer()const{ return drawer; }

	void makeClickable(bool clickable){ this->clickable = clickable; }
	bool isClickable()const{ return clickable; }

	void makeDraggable(bool draggable){ this->draggable = draggable; }
	bool isDraggable()const{ return draggable; }
	
	void makeEditable(bool editable){ this->editable = editable; }
	bool isEditable()const{ return editable; }

	/*returns the position relative to the window*/
	Point getScreenPosition()const{
		if (parent != nullptr)
			return position + parent->getScreenPosition();
		return position;
	}

	/*state*/

	bool isPressed()const{ return pressed; }
	bool isCovered()const{ return covered; }
	bool isDragged()const{ return dragged; }

	/*events*/
	
	bool mouseDown(const MouseButtonEvent& button);
	bool mouseUp(const MouseButtonEvent& button);
	bool mouseMove(const MouseMoveEvent& move);
	bool mouseScroll(const MouseScrollEvent& scroll);
	bool keyDown(const KeyboardEvent& keyboard);
	bool keyUp(const KeyboardEvent& keyboard);
	bool textInput(const TextInputEvent& input);

	void addChild(WidgetPtr child);
	void removeChild(WidgetPtr child);

	Widget* getParent(){ return parent; }

	void setOnMouseButtonDown(OnMouseButtonDown mouseDown){ this->mouseDownCallback = mouseDown; }
	void setOnMouseButtonUp(OnMouseButtonUp mouseUp){ this->mouseUpCallback = mouseUp; }
	void setOnMouseMove(OnMouseMove mouseMove){ this->mouseMoveCallback = mouseMove; }
	void setOnMouseScroll(OnMouseScroll mouseScroll){ this->mouseScrollCallback = mouseScroll; }
	void setOnStartDrag(OnStartDrag startDrag){ this->startDragCallback = startDrag; }
	void setOnDrag(OnDrag drag){ this->dragCallback = drag; }
	void setOnDragEnd(OnEndDrag endDrag){ this->endDragCallback = endDrag; }
	void setOnKeyDown(OnKeyDown keyDown){ this->keyDownCallback = keyDown; }
	void setOnKeyUp(OnKeyUp keyUp){ this->keyUpCallback = keyUp; }
	void setOnTextInput(OnTextInput textInput){ this->textInputCallback = textInput; }

private:
	void swapZOrder(Widget* child, int newOrder);
protected:
	/*overriden in child classes, must return true if the widget must catch the event or false
	otherwise*/

	virtual bool onMouseDown(const MouseButtonEvent& button){ return true; }
	virtual bool onMouseUp(const MouseButtonEvent& button){ return true; }
	virtual bool onMouseMove(const MouseMoveEvent& move){ return true; }
	virtual bool onMouseScroll(const MouseScrollEvent& move){ return true; }
	virtual bool onStartDrag(const MouseMoveEvent& drag){ return true; }
	virtual bool onDrag(const MouseMoveEvent& drag){ return true; }
	virtual bool onEndDrag(const MouseMoveEvent& drag){ return true; }
	virtual bool onKeyDown(const KeyboardEvent& keyboard){ return true; }
	virtual bool onKeyUp(const KeyboardEvent& keyboard){ return true; }
	virtual bool onTextInput(const TextInputEvent& input){ return true; }

	/*Calculate the amount that the widget should be moved based on the drag event*/
	virtual Size calculateDrag(const MouseMoveEvent& drag){ return drag.getDrag(); }

	void startDrag(const MouseMoveEvent& drag);
	void drag(const MouseMoveEvent& drag);
	void endDrag(const MouseMoveEvent& drag);

	Box* box;
	Widget* parent;
	std::map<int, std::list<WidgetPtr>> childs;	//childs stored in layers(see zOrder)

	DrawerPtr drawer;
	Point position;			//Position in the screen
	Point scrolledPosition;	//Position that determines the visible portion of the widget
	Size size;

	int zOrder;

	bool clickable;
	bool draggable;
	bool editable;

	/*state flags*/

	bool pressed;	/*mouse is down or not*/
	bool covered;	/*mouse is over or not*/
	bool dragged;	/*is being dragged or not*/

	/*callbacks*/

	OnMouseButtonDown mouseDownCallback;
	OnMouseButtonUp mouseUpCallback;
	OnMouseMove mouseMoveCallback;
	OnMouseScroll mouseScrollCallback;
	OnStartDrag startDragCallback;
	OnDrag dragCallback;
	OnEndDrag endDragCallback;
	OnKeyDown keyDownCallback;
	OnKeyUp keyUpCallback;
	OnTextInput textInputCallback;
};

#endif